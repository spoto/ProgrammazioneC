\documentclass[12pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{listings, xcolor}
\usepackage{textcomp}

\definecolor{verylightgray}{rgb}{.97,.97,.97}
\definecolor{lightred}{rgb}{.97,.50,.50}

\lstdefinelanguage{myC}{
        keywords=[1]{break, case, continue, default, do
, else, false, for, if, const, return, switch, true, while}, % generic keywords
        keywordstyle=[1]\color{blue}\bfseries,
        keywords=[2]{bool, int, long, float, double, byte, short, char, void, signed, unsigned}, % types
        keywordstyle=[2]\color{teal}\bfseries,
        keywordstyle=[2]\color{violet}\bfseries,
        keywords=[3]{NULL},
        keywordstyle=[3]\color{teal}\bfseries,
        identifierstyle=\color{black},
        sensitive=false,
        comment=[l]{//},
        morecomment=[s]{/*}{*/},
        commentstyle=\color{violet}\ttfamily,
        commentstyle=\small\ttfamily\color{myGreen},
        stringstyle=\color{red}\ttfamily,
        morestring=[b]',
        morestring=[b]"
}

\lstset{
        language=myC,
        backgroundcolor=\color{verylightgray},
        extendedchars=true,
        basicstyle=\small\ttfamily,
        showstringspaces=false,
        showspaces=false,
        numbers=none,
        numberstyle=\small,
        numbersep=9pt,
        tabsize=2,
        upquote=true,
        breaklines=true,
        showtabs=false,
        captionpos=b
        otherkeywords={define,include,\# }
}

\definecolor{myBlue}{rgb}{0.5,0.5,1}
\definecolor{myLightBlue}{rgb}{0.35,0.6,0.8}
\definecolor{myBlack}{rgb}{0,0,0}
\definecolor{myGreen}{rgb}{0.1,0.6,0.2}
\definecolor{myGray}{rgb}{0.5,0.5,0.5}
\definecolor{myLightgray}{rgb}{0.95,0.95,0.95}
\definecolor{myMauve}{rgb}{0.58,0,0.82}
\lstdefinelanguage{customc}{
    language=C,
    backgroundcolor = \color{myLightgray},
    basicstyle=\small\ttfamily\color{myBlack},
    keywordstyle=\color{myLightBlue},
    keywordstyle=[2]\color{red},
    commentstyle=\small\ttfamily\color{myGreen},
    morekeywords={RequirePackage,ProvidesPackage},
    %
    % The special highlighting works for '!if', '!endif' and '!else'
    % But it doesn't work for '#if', '#endif' and '#else'.
    alsoletter = {!},
    keywords=[2]{!if,!endif,!else},
    otherkeywords={define,include,\# }
}

\lstdefinestyle{myCustomc}{
    language = customc,
    % keywordstyle = \color{myMauve},
}

\lstset{escapechar=@,style=myCustomc}


\definecolor{grey}{rgb}{0.3,0.3,0.3}
\definecolor{lightgrey}{rgb}{0.9,0.9,0.9}

\thispagestyle{empty}
\setlength{\textwidth}{18.5cm}
\setlength{\topmargin}{-2.5cm}
\setlength{\textheight}{24.5cm}
\setlength{\oddsidemargin}{-1cm}
\setlength{\evensidemargin}{-1cm}

\begin{document}
\begin{center}{\LARGE Compito di Programmazione - Bioinformatica}\\
  \large 5 febbraio 2025 (tempo disponibile: 2 ore)\\
  \textbf{(si consegnino \texttt{list.c}, \texttt{list.h} e \texttt{main.c})}
\end{center}

\vspace*{1ex}
\begin{center}{\Large Esercizio 1} ($20$ punti)
\end{center}

Si completi il seguente file \texttt{list.c}. Si noti che la definizione della
struttura \texttt{List} \`e gi\`a fornita dentro \texttt{list.h}.

\begin{center}
\begin{lstlisting}[language=myC]
// aggiungete gli #include necessari

struct List *create(int head, struct List *tail) {
  // ritorna una nuova lista con la testa e la coda indicate
}

void print(struct List *this) {
  // stampa gli elementi di this, dal primo all'ultimo, su una
  // riga, separati da spazi, andando a capo alla fine;
  // si noti che this potrebbe essere NULL
}

struct List *from(int arr[], int length) {
  // ritorna una lista contenente esattamente gli elementi
  // di arr, lungo length, nell'ordine in cui sono presenti
  // nell'array; se length fosse 0, dovra' ritornare NULL
}

struct List *filter(struct List *this, int threshold) {
  // ritorna una lista contenente i soli elementi di this
  // che sono maggiori o uguali a threshold;
  // si noti che this puo' essere NULL e che il risultato
  // sara' NULL se non ci fossero elementi maggiori o uguali
  // a threshold
  
  // QUESTA FUNZIONE DEVE ESSERE RICORSIVA
}

struct List *duplicate(struct List *this) {
  // ritorna una lista identica a this ma con gli elementi
  // duplicati; per esempio, se this fosse la lista 1 2 3, allora
  // questa funzione deve ritornare la lista 1 1 2 2 3 3;
  // si noti che this puo' essere NULL e che il risultato sara'
  // NULL se this fosse vuota

  // QUESTA FUNZIONE DEVE ESSERE RICORSIVA
}
\end{lstlisting}
\end{center}

\newpage
\begin{center}
  {\Large Esercizio 2} ($2$ punti)
\end{center}

Si completi il file \texttt{list.h} con le dichiarazioni delle funzioni
di \texttt{list.c}.

\vspace{2ex}
\begin{center}
  {\Large Esercizio 3} ($9$ punti)
\end{center}

Si scriva un file \texttt{main.c} che dichiara una funzione \texttt{main} che,
usando le funzioni di \texttt{list.c}:

\begin{enumerate}
\item crea una lista \texttt{l} contenente esattamente gli elementi
  7, 17, -11, 13, 17;
\item stampa \texttt{l};
\item filtra la lista \texttt{l} ai soli elementi maggiori o uguali a 10,
  chiamando \texttt{f} il risultato;
\item stampa \texttt{f};
\item stampa \texttt{l};
\item filtra la lista \texttt{l} ai soli elementi maggiori o uguali a 40,
  chiamando \texttt{g} il risultato;
\item stampa \texttt{g};
\item crea una lista ottenuta duplicando gli elementi di \texttt{l},
  chiamando \texttt{d} il risultato;
\item stampa \texttt{d};
\item stampa \texttt{l}.
\end{enumerate}

\hrule
\mbox{}\\

Se tutto \`e corretto, l'esecuzione della compilazione congiunta
di \texttt{list.c} e di \texttt{main.c} dovr\`a stampare:

\begin{mdframed}[backgroundcolor=lightgrey] 
\begin{verbatim}
l = 7 17 -11 13 17 
f = 17 13 17 
l = 7 17 -11 13 17 
g = 
d = 7 7 17 17 -11 -11 13 13 17 17 
l = 7 17 -11 13 17 
\end{verbatim}
\end{mdframed}

\begin{mdframed}[backgroundcolor=lightred] 
  \textbf{Se servisse, negli esercizi si possono aggiungere funzioni ausiliarie.}
\end{mdframed}

\end{document}
