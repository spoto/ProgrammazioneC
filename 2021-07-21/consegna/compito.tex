\documentclass[12pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{color}
\usepackage{graphicx}
\usepackage{mdframed}
\usepackage{listings, xcolor}
\usepackage{textcomp}

\definecolor{verylightgray}{rgb}{.97,.97,.97}

\lstdefinelanguage{myC}{
        keywords=[1]{break, case, continue, default, do
, else, false, for, if, const, return, switch, true, while}, % generic keywords
        keywordstyle=[1]\color{blue}\bfseries,
        keywords=[2]{bool, int, long, float, double, byte, short, char, void, signed, unsigned}, % types
        keywordstyle=[2]\color{teal}\bfseries,
        keywordstyle=[2]\color{violet}\bfseries,
        keywords=[3]{NULL},
        keywordstyle=[3]\color{teal}\bfseries,
        identifierstyle=\color{black},
        sensitive=false,
        comment=[l]{//},
        morecomment=[s]{/*}{*/},
        commentstyle=\color{violet}\ttfamily,
        commentstyle=\scriptsize\ttfamily\color{myGreen},
        stringstyle=\color{red}\ttfamily,
        morestring=[b]',
        morestring=[b]"
}

\lstset{
        language=myC,
        backgroundcolor=\color{verylightgray},
        extendedchars=true,
        basicstyle=\small\ttfamily,
        showstringspaces=false,
        showspaces=false,
        numbers=none,
        numberstyle=\small,
        numbersep=9pt,
        tabsize=2,
        upquote=true,
        breaklines=true,
        showtabs=false,
        captionpos=b
        otherkeywords={define,include,\# }
}

\definecolor{myBlue}{rgb}{0.5,0.5,1}
\definecolor{myLightBlue}{rgb}{0.35,0.6,0.8}
\definecolor{myBlack}{rgb}{0,0,0}
\definecolor{myGreen}{rgb}{0.1,0.6,0.2}
\definecolor{myGray}{rgb}{0.5,0.5,0.5}
\definecolor{myLightgray}{rgb}{0.95,0.95,0.95}
\definecolor{myMauve}{rgb}{0.58,0,0.82}

\lstdefinelanguage{customc}{
    language=C,
    backgroundcolor = \color{myLightgray},
    basicstyle=\scriptsize\ttfamily\color{myBlack},
    keywordstyle=\color{myLightBlue},
    keywordstyle=[2]\color{red},
    commentstyle=\scriptsize\ttfamily\color{myGreen},
    morekeywords={RequirePackage,ProvidesPackage},
    %
    % The special highlighting works for '!if', '!endif' and '!else'
    % But it doesn't work for '#if', '#endif' and '#else'.
    alsoletter = {!},
    keywords=[2]{!if,!endif,!else},
    otherkeywords={define,include,\# }
}

\lstdefinestyle{myCustomc}{
    language = customc,
    % keywordstyle = \color{myMauve},
}

\lstset{escapechar=@,style=myCustomc}


\definecolor{grey}{rgb}{0.3,0.3,0.3}
\definecolor{lightgrey}{rgb}{0.9,0.9,0.9}

\thispagestyle{empty}
\setlength{\textwidth}{18.5cm}
\setlength{\topmargin}{-2.5cm}
\setlength{\textheight}{24.5cm}
\setlength{\oddsidemargin}{-1cm}
\setlength{\evensidemargin}{-1cm}
\begin{document}
\begin{center}{\LARGE Esame Completo di Programmazione I - Bioinformatica}\\
%\vspace*{-1ex}
\begin{center}
  \large 21 luglio 2021 (tempo disponibile: 2 ore)
\end{center}
\end{center}

\vspace*{1ex}
\begin{center}{\Large Esercizio 1} ($15$ punti)\\
  \textbf{(si consegni \texttt{ordina.c})}
\end{center}
Si completi il seguente programma \texttt{ordina.c} che implementa le seguenti funzioni:

\begin{center}
\begin{lstlisting}[language=myC]
// inizializza l'array lungo length con numeri casuali tra 0 e 4 inclusi
void init_random(int arr[], int length) {
  // DA COMPLETARE
}

// stampa su una riga l'array lungo length e poi va a capo
void print(int arr[], int length) {
  // DA COMPLETARE
}

// calcola quante volte value e' presente dentro l'array lungo length
int how_many(int arr[], int length, int value) {
  // DA COMPLETARE
}

// determina se arr[pos] e' in ordine errato col successore arr[pos + 1],
// cioe' arr[pos] e' meno frequente di arr[pos + 1]
// oppure entrambi hanno la stessa frequenza ma arr[pos] e' maggiore di arr[pos + 1];
// si assuma che 0 <= pos < length - 1
int must_swap(int arr[], int length, int pos) {
  // DA COMPLETARE
}

// mette in ordine l'array in modo che gli elementi piu' frequenti siano
// messi al suo inizio; a parita' di frequenza, mette prima gli elementi minori
void more_frequent_first(int arr[], int length) {
  // DA COMPLETARE
}

int main(void) {
  int arr[20];
  init_random(arr, 20);
  print(arr, 20); // stampa prima dell'ordinamento
  more_frequent_first(arr, 20);
  print(arr, 20); // stampa dopo l'ordinamento
  return 0;
}
\end{lstlisting}
\end{center}

\noindent
L'esecuzione del programma dovr\`a stampare qualcosa del tipo:

\begin{mdframed}[backgroundcolor=lightgrey] 
{\scriptsize\begin{verbatim}
1 4 3 3 0 3 0 4 3 4 2 4 4 4 2 4 4 1 2 2 
4 4 4 4 4 4 4 4 2 2 2 2 3 3 3 3 0 0 1 1
\end{verbatim}}
\end{mdframed}

\noindent
In questo esempio, il valore pi\`u frequente nell'array \`e 4, presente otto volte, e infatti
viene spostato all'inizio. Poi seguono il 2 e il 3, che sono presenti quattro volte ciascuno,
e si mette prima il 2 perch\'e \`e minore. Poi seguono lo 0 e l'1, che
sono presenti due volte ciascuno, e si mette prima lo 0 perch\'e \`e minore.
\newpage
\mbox{}\\
\begin{center}{\Large Esercizio 2} ($16$ punti)\\
  \textbf{(si consegni \texttt{calcoli.c})}\end{center}
Si completi il seguente programma \texttt{calcoli.c}, la cui funzione \texttt{main()} calcola la percentuale di equazioni corrette presenti in un file il cui contenuto \`{e} una sequenza (di lunghezza ignota) di uguaglianze tra somme di interi positivi, ciascuna terminata da un punto e virgola, e senza spazi bianchi. Il file di esempio potrebbe essere
\begin{verbatim}
2+3+10=7+8;
1+2+3+4+5=15;
33=3+4+5+6+7+8;
3+5+4=1+18;
\end{verbatim}
\begin{center}
\begin{lstlisting}[language=myC]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int myerror(char *message);
int myfclose(FILE *f);
FILE * myfopen(char *name, char *mode);
float calcola(FILE* fp);

int main()
{
    char filename[6] = "in.txt";
    FILE* fp;
    fp = myfopen(filename,"r");
    float risultato = calcola(fp);
    myfclose(fp);
    printf("Le equazioni corrette sono il %.2f %% \n",(risultato*100));
    return 0;
}

int myerror(char *message)
{
    fputs( message, stderr );
    exit(1);
}
/**
 *  chiude  lo stream su file controllando se ci sono errori,
 *  invoca myerror sia che f sia null sia che il risultato delle
 *  chiusura sia diverso da zero
 */
int myfclose(FILE *f)
{
     // DA COMPLETARE
}
/**
*  apre  lo stream su file controllando se ci sono errori,
*  invoca myerror se f \`{e} null
*/
FILE * myfopen(char *name, char *mode)
{
     // DA COMPLETARE
}
/**
*  legge un file identificato da FILE * f, distingue la singole equazioni
*  grazie al ";" che ne determina la fine,
*  restituisce la frazione di equazioni corrette sul totale
*/
float calcola(FILE* fp)
{
     int parte_sin = 1;
     // DA COMPLETARE
}
\end{lstlisting}
\end{center}
La sua esecuzione, con il file di esempio sopra specificato, dovr\`a stampare sul video:
\begin{mdframed}[backgroundcolor=lightgrey] 
\begin{verbatim}
Le equazioni corrette sono il 75.00 %
\end{verbatim}
\end{mdframed}

\mbox{}\\
Si osservi che:
\begin{itemize}
\item La soluzione richiesta ignora la divisione in righe e si basa soltanto sui caratteri che seguono i numeri (cio\`{e} +, = e ;)
\item Suggerimento: la soluzione richiesta pu\`{o} utilizzare una variabile booleana, chiamata parte\_sin, che tiene traccia del fatto che si sta analizzando la parte a sinistra o a destra del segno di uguaglianza.
\end{itemize}
\end{document}
